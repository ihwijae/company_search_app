# SMPP 중소/여성기업 실시간 조회 기능 설계서 (Electron / Node.js용)

대상 시스템: https://www.smpp.go.kr (중소기업현황 정보시스템)  
적용 대상: 기존 Electron 기반 협력업체 관리 프로그램 (Node.js 백엔드 / Renderer 프론트)  
목표: **사업자등록번호 입력 시, 실시간으로 “소기업 / 여성기업” 확인일자·만료일자 조회 후 UI에 바로 표시**

---

## 1. 요구사항 정리

### 1.1 기능 관점

- 사용자가 Electron 앱에서 **사업자등록번호**를 입력하고 “조회” 버튼 클릭
- 앱이 `smpp.go.kr`에 로그인 → 해당 사업자번호로 업체 검색 → 상세(기업특징) 페이지 진입
- **기업특징 테이블**에서 아래 정보 실시간 조회:
  - 소기업 여부 + 확인일자 + 만료일자
  - 여성기업 여부 + 확인일자 + 만료일자
- 조회 결과를 **UI에 바로 표시** (엑셀 저장은 나중 단계)

### 1.2 기술 제약 / 선택

- HTTP 통신: `axios` + `tough-cookie` + `axios-cookiejar-support`
- HTML 파싱: `cheerio`
- 로그인/조회 로직: **Electron 메인 프로세스(Node)** 에서 수행
- UI: Renderer (React 등) → IPC를 통해 메인에 요청 → 응답 받은 결과 표시

---

## 2. SMPP HTTP 동작 구조 요약

### 2.1 로그인

#### 2.1.1 흐름

1. `GET /uat/uia/egovLoginUsr.do`  
   → 로그인 페이지 HTML + 초기 쿠키(JSESSIONID 등)
2. HTML 내 `<form name="loginForm" ...>` 파싱
3. `<input>` 태그들 전부 읽어서 `formData` 구성
4. `formData.id = USER_ID`, `formData.password = USER_PW` 로 덮어씀
5. `POST /uat/uia/actionLogin.do` 로 `formData` 전송
6. 성공 시 `/?loginSuccess=true` 화면으로 이동 (응답 HTML은 메인 페이지 형태)

#### 2.1.2 구현 포인트 (Node)

- 로그인 시 **폼 전체를 serialize** 하는 방식 사용 (hidden 필드 포함)
- 반드시 `egovLoginUsr.do` GET → `loginForm` 파싱 → `actionLogin.do` POST 순서

---

### 2.2 사업자등록번호로 업체 목록 조회

#### 2.2.1 요청

- **URL**

  ```text
  POST https://www.smpp.go.kr/cop/registcorp/selectRegistCorpListVw.do
Form Data (핵심)

js
코드 복사
{
  chks: "",
  fileType: "",
  pageIndex: "1",
  ctprvnNm: "전체",
  signguNm: "전체",
  cntrctEsntlNo: "",
  entrpsNm: "",
  searchBsnmNo: "<사업자번호>",  // 예: "216-81-15499" 또는 숫자만
  chargerNm: "",
  detailPrdnm: "",
  detailPrdnmNo: "",
  ksicNm: "",
  ksic: "",
  prductNm: "",
  ctprvnCode: "",
  signguCode: "",
  smbizCode: "",
  femtrbleCode: "",
  hitechCode: "",
  envqualCode: "",
  entrpsNmMbl: "",
  searchBsnmNoMbl: "",
  chargerNmMbl: "",
  pageUnit: "15",
}
응답: 업체 목록 HTML (검색 결과 테이블 + moveForm 폼 포함)

2.2.2 중요 포인트
목록 HTML에 상세 페이지로 가는 직접적인 링크(href) 가 없음.

대신, 업체명을 클릭하면 JS 함수 fn_moveDetail(bsnmNo) 가 호출되며,
이 함수가 숨은 폼 moveForm를 채우고 submit 하는 구조.

2.3 상세(기업특징) 페이지 이동 – 문제 원인 & 해결 방식
2.3.1 잘못된 예상 (처음 접근)
처음에는 목록 HTML에 다음과 같은 링크가 있을 거라 예상:

html
코드 복사
<a href="/cop/registcorp/selectRegistCorpSumryInfoVw.do?registCorpSn=12345">...</a>
그래서 Node에서도 href에서 selectRegistCorpSumryInfoVw.do 를 찾으려 했지만,
실제 구조는 그렇지 않음.

2.3.2 실제 구조
목록에서 업체명 링크는 다음과 같이 되어 있음:

html
코드 복사
<a href="#" class="subject" onClick="javascript:fn_moveDetail('2168115499')">
  (주)대상전력
</a>
JS:

javascript
코드 복사
// 상세화면으로 이동
function fn_moveDetail(bsnmNo){
    var obj = document.moveForm;
    obj.bsnmNo.value = bsnmNo;
    obj.action = "/cop/registcorp/selectRegistCorpSumryInfoVw.do";
    obj.submit();
}
숨은 폼:

html
코드 복사
<form name="moveForm" method="post">
  <input type="hidden" name="cntrctEsntlNo" value=""/>
  <input type="hidden" name="menuId" value="5040101"/>
  <input type="hidden" name="pageIndex" value="1"/>
  <input type="hidden" name="searchBsnmNo" value="2168115499" title="검색 사업자번호"/>
  <input type="hidden" name="bsnmNo" value="" title="사업자번호"/>
  ...
</form>
브라우저 동작 요약:

(주)대상전력 클릭 → fn_moveDetail('2168115499')

moveForm.bsnmNo = '2168115499'

moveForm.action = '/cop/registcorp/selectRegistCorpSumryInfoVw.do'

moveForm.submit() → 상세 페이지 POST

2.3.3 Node에서의 해결 전략
Node에서는 JS를 실행할 수 없으므로,
“JS 결과”를 직접 흉내 내는 방식으로 처리해야 함:

목록 HTML에서 <form name="moveForm"> 를 cheerio로 파싱

그 안의 <input type="hidden"> 들을 모두 읽어서 payload 객체를 구성

payload.bsnmNo 에 사업자번호(숫자만) 세팅

payload.searchBsnmNo 가 비어 있으면 동일 값으로 세팅

이 payload 를 가지고 selectRegistCorpSumryInfoVw.do 에 POST

2.4 상세(기업특징) 페이지 요청
URL

text
코드 복사
POST https://www.smpp.go.kr/cop/registcorp/selectRegistCorpSumryInfoVw.do
Form Data

위에서 만든 payload 그대로 사용 (moveForm 기반)

응답

업체 상세 요약 페이지 HTML

여기 안에 “기업특징” 테이블 존재

예시 구조:

html
코드 복사
<span class="labelType1">기업특징</span>
<div class="tbl_type col">
  <table>
    <thead>
      <tr>
        <th>구분</th>
        <th>확인기관</th>
        <th>확인일자</th>
        <th>만료일자</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>소기업</td>
        <td>중소벤처기업부</td>
        <td>2025-04-01</td>
        <td>2026-03-31</td>
      </tr>
      <tr>
        <td>여성기업</td>
        <td>...</td>
        <td>2024-08-14</td>
        <td>2027-08-13</td>
      </tr>
      ...
    </tbody>
  </table>
</div>
2.5 기업특징 테이블 파싱 (Node / cheerio)
2.5.1 목표
구분 = "소기업" 인 행 → 소기업 확인일자 / 만료일자

구분 = "여성기업" 인 행 → 여성기업 확인일자 / 만료일자

2.5.2 파싱 전략 (개략)
ts
코드 복사
import * as cheerio from "cheerio";

type BizFeature = {
  exists: boolean;
  confirmDate: string | null;
  expireDate: string | null;
};

type CorpFeatures = {
  small: BizFeature;
  women: BizFeature;
};

function parseCorpFeatures(html: string): CorpFeatures {
  const $ = cheerio.load(html);

  // '기업특징' 라벨 뒤에 나오는 첫 번째 table
  const span = $('span.labelType1').filter((_, el) => $(el).text().includes("기업특징")).first();
  if (!span.length) {
    return emptyFeatures();
  }

  const table = span.nextAll("table").first();
  if (!table.length) {
    return emptyFeatures();
  }

  const small: BizFeature = { exists: false, confirmDate: null, expireDate: null };
  const women: BizFeature = { exists: false, confirmDate: null, expireDate: null };

  table.find("tbody tr").each((_, tr) => {
    const tds = $(tr).find("td");
    if (!tds.length) return;

    const kind = $(tds[0]).text().trim(); // "소기업", "여성기업" 등

    const hasNoData = $(tds).slice(1).toArray().some(td =>
      $(td).text().includes("해당사항 없음")
    );
    if (hasNoData) return;

    if (kind === "소기업" && tds.length >= 4) {
      small.exists = true;
      small.confirmDate = $(tds[2]).text().trim() || null;
      small.expireDate  = $(tds[3]).text().trim() || null;
    }

    if (kind === "여성기업" && tds.length >= 4) {
      women.exists = true;
      women.confirmDate = $(tds[2]).text().trim() || null;
      women.expireDate  = $(tds[3]).text().trim() || null;
    }
  });

  return { small, women };
}

function emptyFeatures(): CorpFeatures {
  return {
    small: { exists: false, confirmDate: null, expireDate: null },
    women: { exists: false, confirmDate: null, expireDate: null },
  };
}
3. Node/Electron 모듈 구조 제안
3.1 HTTP 클라이언트 레벨 (smppHttp.ts)
역할: SMPP와 HTTP 통신만 담당 (로그인, 목록 조회, 상세 조회)

ts
코드 복사
// smppHttp.ts (Node / main process)

import axios, { AxiosInstance } from "axios";
import { CookieJar } from "tough-cookie";
import { wrapper } from "axios-cookiejar-support";
import * as cheerio from "cheerio";

const LOGIN_PAGE_URL   = "https://www.smpp.go.kr/uat/uia/egovLoginUsr.do";
const LOGIN_ACTION_URL = "https://www.smpp.go.kr/uat/uia/actionLogin.do";
const LIST_URL         = "https://www.smpp.go.kr/cop/registcorp/selectRegistCorpListVw.do";
const SUMMARY_URL      = "https://www.smpp.go.kr/cop/registcorp/selectRegistCorpSumryInfoVw.do";

export async function createSmppClient(
  userId: string,
  password: string,
): Promise<AxiosInstance> {
  const jar = new CookieJar();
  const client = wrapper(axios.create({
    jar,
    withCredentials: true,
    headers: {
      "User-Agent":
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) " +
        "AppleWebKit/537.36 (KHTML, like Gecko) " +
        "Chrome/142.0.0.0 Safari/537.36",
    },
  }));

  // 1) 로그인 페이지 GET
  const pre = await client.get(LOGIN_PAGE_URL);
  const $ = cheerio.load(pre.data);

  const form = $('form[name="loginForm"], form#loginForm').first();
  if (!form.length) {
    throw new Error("loginForm not found");
  }

  const formData: Record<string, string> = {};
  form.find("input[name]").each((_, el) => {
    const name = $(el).attr("name")!;
    const value = $(el).attr("value") ?? "";
    formData[name] = value;
  });

  formData["id"] = userId;
  formData["password"] = password;

  await client.post(LOGIN_ACTION_URL, new URLSearchParams(formData).toString(), {
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      "Origin": "https://www.smpp.go.kr",
      "Referer": LOGIN_PAGE_URL,
    },
  });

  // 이후 요청에서 목록/상세가 로그인 페이지로 튀는지 여부로 로그인이 유지되는지 확인
  return client;
}

export async function fetchListHtml(
  client: AxiosInstance,
  bizNo: string,
): Promise<string> {
  const data = new URLSearchParams({
    chks: "",
    fileType: "",
    pageIndex: "1",
    ctprvnNm: "전체",
    signguNm: "전체",
    cntrctEsntlNo: "",
    entrpsNm: "",
    searchBsnmNo: bizNo,
    chargerNm: "",
    detailPrdnm: "",
    detailPrdnmNo: "",
    ksicNm: "",
    ksic: "",
    prductNm: "",
    ctprvnCode: "",
    signguCode: "",
    smbizCode: "",
    femtrbleCode: "",
    hitechCode: "",
    envqualCode: "",
    entrpsNmMbl: "",
    searchBsnmNoMbl: "",
    chargerNmMbl: "",
    pageUnit: "15",
  });

  const resp = await client.post(LIST_URL, data.toString(), {
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
  });

  return resp.data;
}

export async function fetchSummaryHtmlFromList(
  client: AxiosInstance,
  listHtml: string,
  bizNo: string,
): Promise<string> {
  const $ = cheerio.load(listHtml);

  const moveForm = $('form[name="moveForm"]').first();
  if (!moveForm.length) {
    throw new Error("moveForm not found");
  }

  const payload: Record<string, string> = {};
  moveForm.find("input[name]").each((_, el) => {
    const name = $(el).attr("name")!;
    const value = $(el).attr("value") ?? "";
    payload[name] = value;
  });

  // bizNo에서 숫자만 추출해서 bsnmNo 세팅
  const digits = bizNo.replace(/\D/g, "");
  payload["bsnmNo"] = digits;

  if ("searchBsnmNo" in payload && !payload["searchBsnmNo"]) {
    payload["searchBsnmNo"] = digits;
  }

  const resp = await client.post(
    SUMMARY_URL,
    new URLSearchParams(payload).toString(),
    { headers: { "Content-Type": "application/x-www-form-urlencoded" } },
  );

  return resp.data;
}
3.2 파싱 레벨 (smppParser.ts)
위에서 작성한 parseCorpFeatures(html) 함수를 cheerio 기반으로 구현.
실시간 조회 용으로는 아래 타입 정도면 충분:

ts
코드 복사
export type BizFeature = {
  exists: boolean;
  confirmDate: string | null;
  expireDate: string | null;
};

export type CorpFeatures = {
  small: BizFeature;
  women: BizFeature;
};
3.3 서비스 레벨 (smppService.ts)
한 번의 호출로 한 업체 기준 실시간 조회를 처리하는 서비스.

ts
코드 복사
// smppService.ts

import { AxiosInstance } from "axios";
import {
  createSmppClient,
  fetchListHtml,
  fetchSummaryHtmlFromList,
} from "./smppHttp";
import { parseCorpFeatures, CorpFeatures } from "./smppParser";

export type SingleCheckResult = {
  bizNo: string;
  features: CorpFeatures | null;
  error?: string;
};

let cachedClient: AxiosInstance | null = null;
let cachedCreds: { id: string; pw: string } | null = null;

export async function checkSingleCorp(
  userId: string,
  password: string,
  bizNo: string,
): Promise<SingleCheckResult> {
  try {
    // 세션 재사용 (ID/PW가 동일하면 기존 client 사용)
    if (!cachedClient || !cachedCreds || cachedCreds.id !== userId || cachedCreds.pw !== password) {
      cachedClient = await createSmppClient(userId, password);
      cachedCreds = { id: userId, pw: password };
    }

    const listHtml = await fetchListHtml(cachedClient, bizNo);

    // 간단한 로그인 페이지 판별
    if (listHtml.includes("name=\"loginForm\"") && listHtml.includes("로그인")) {
      // 세션이 끊겼다고 보고 새로 로그인
      cachedClient = await createSmppClient(userId, password);
      cachedCreds = { id: userId, pw: password };
      const retryList = await fetchListHtml(cachedClient, bizNo);
      return await handleSummary(retryList, bizNo);
    }

    return await handleSummary(listHtml, bizNo);
  } catch (err: any) {
    return { bizNo, features: null, error: String(err?.message ?? err) };
  }
}

async function handleSummary(listHtml: string, bizNo: string): Promise<SingleCheckResult> {
  const summaryHtml = await fetchSummaryHtmlFromList(cachedClient!, listHtml, bizNo);
  const features = parseCorpFeatures(summaryHtml);
  return { bizNo, features };
}
3.4 IPC 핸들러 (Electron 메인)
ts
코드 복사
// main/ipcSmpp.ts

import { ipcMain } from "electron";
import { checkSingleCorp } from "./smppService";

ipcMain.handle("smpp:check-one", async (event, args) => {
  const { id, password, bizNo } = args;
  return await checkSingleCorp(id, password, bizNo);
});
3.5 Renderer(프론트) 사용 예시
ts
코드 복사
// renderer (React 예시)

async function handleCheck() {
  setLoading(true);
  try {
    const result = await window.api.invoke("smpp:check-one", {
      id: smppId,
      password: smppPw,
      bizNo: inputBizNo,
    });

    // result.features.small / result.features.women 사용
    setResult(result);
  } finally {
    setLoading(false);
  }
}
UI에서는:

입력: SMPP ID / PW (또는 1회 로그인 후 캐싱)

입력: 사업자등록번호

버튼: “조회”

출력:

소기업: 존재 여부 / 확인일자 / 만료일자

여성기업: 존재 여부 / 확인일자 / 만료일자

에러 발생 시 result.error 메세지 표시

4. 요약 – “상세 페이지 안 뜨던 문제” 핵심 인계 포인트
로그인은 egovLoginUsr.do → loginForm 파싱 → actionLogin.do POST 패턴 사용 (폼 전체 전송)

사업자번호 검색은 selectRegistCorpListVw.do 에 searchBsnmNo 로 POST

상세 페이지는 직접 링크가 아닌
fn_moveDetail(bsnmNo) + form[name="moveForm"] 를 통한 submit 구조

Node/Electron에서는:

목록 HTML에서 moveForm hidden input들을 모두 읽어서 payload 구성

payload.bsnmNo 를 사업자번호(숫자만)로 세팅

이 payload를 selectRegistCorpSumryInfoVw.do 에 POST하여 상세 페이지 HTML 획득

상세 페이지의 “기업특징” 테이블에서
"중소기업" / "여성기업" 행의 3·4번째 컬럼을 파싱해
확인일자 / 만료일자를 가져오면 된다.